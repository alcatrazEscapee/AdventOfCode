# Font recognition for the two (2) puzzles that have invoked it so far (2021 Day 13 and ... that one with the flying points from 2018?)

from utils import InfiniteGrid

# Yes, this was generated by trawling through github for various inputs for day 13 and running them
# No, it might not have all the possible letters that are generated
# Yes, it seems to exclude ambiguous letters, almost surely intentionally (also notably 'M' or 'W' which would require variable width characters)
# Yes, getting all those inputs was tedious
LETTERS = {
    ('A', ('.##.', '#..#', '#..#', '####', '#..#', '#..#')),
    ('B', ('###.', '#..#', '###.', '#..#', '#..#', '###.')),
    ('C', ('.##.', '#..#', '#...', '#...', '#..#', '.##.')),
    ('E', ('####', '#...', '###.', '#...', '#...', '####')),
    ('F', ('####', '#...', '###.', '#...', '#...', '#...')),
    ('G', ('.##.', '#..#', '#...', '#.##', '#..#', '.###')),
    ('H', ('#..#', '#..#', '####', '#..#', '#..#', '#..#')),
    ('J', ('..##', '...#', '...#', '...#', '#..#', '.##.')),
    ('K', ('#..#', '#.#.', '##..', '#.#.', '#.#.', '#..#')),
    ('L', ('#...', '#...', '#...', '#...', '#...', '####')),
    ('P', ('###.', '#..#', '#..#', '###.', '#...', '#...')),
    ('R', ('###.', '#..#', '#..#', '###.', '#.#.', '#..#')),
    ('U', ('#..#', '#..#', '#..#', '#..#', '#..#', '.##.')),
    ('Z', ('####', '...#', '..#.', '.#..', '#...', '####'))
}

HEIGHT = 6
WIDTH = 4


def recognize(grid: InfiniteGrid) -> str:
    min_x, min_y, width, height = grid.bounds()

    assert (width + 1) % (WIDTH + 1) == 0, 'Uneven amount of letters: width %d' % width
    assert height == HEIGHT, 'Font height %d != 6' % height

    dx = 0
    letters = []
    while dx < width:
        for letter, pattern in LETTERS:
            if dx + WIDTH <= width:  # This letter can fit in the provided width
                if all(pattern[y][x] == grid[min_x + dx + x, min_y + y]
                       for x in range(WIDTH)
                       for y in range(HEIGHT)):
                    letters.append(letter)
                    dx += WIDTH + 1
                    break
        else:
            raise ValueError('No matching text found! Found start = %s at offset dx = %d' % (letters, dx))
    return ''.join(letters)
