# Font recognition for the two (2) puzzles that have invoked it so far (2021 Day 13 and ... that one with the flying points from 2018?)

from typing import Set, Tuple

# Yes, this was generated by trawling through github for various inputs for day 13 and running them
# No, it might not have all the possible letters that are generated
# Yes, it seems to exclude ambiguous letters, almost surely intentionally (also notably 'M' or 'W' which would require variable width characters)
# Yes, getting all those inputs was tedious
LETTERS = {
    ('A', ('.##.', '#..#', '#..#', '####', '#..#', '#..#')),
    ('B', ('###.', '#..#', '###.', '#..#', '#..#', '###.')),
    ('C', ('.##.', '#..#', '#...', '#...', '#..#', '.##.')),
    ('E', ('####', '#...', '###.', '#...', '#...', '####')),
    ('F', ('####', '#...', '###.', '#...', '#...', '#...')),
    ('G', ('.##.', '#..#', '#...', '#.##', '#..#', '.###')),
    ('H', ('#..#', '#..#', '####', '#..#', '#..#', '#..#')),
    ('J', ('..##', '...#', '...#', '...#', '#..#', '.##.')),
    ('K', ('#..#', '#.#.', '##..', '#.#.', '#.#.', '#..#')),
    ('L', ('#...', '#...', '#...', '#...', '#...', '####')),
    ('P', ('###.', '#..#', '#..#', '###.', '#...', '#...')),
    ('R', ('###.', '#..#', '#..#', '###.', '#.#.', '#..#')),
    ('U', ('#..#', '#..#', '#..#', '#..#', '#..#', '.##.')),
    ('Z', ('####', '...#', '..#.', '.#..', '#...', '####'))
}

HEIGHT = 6
WIDTH = 4


def recognize(points: Set[Tuple[int, int]], min_x: int, max_x: int, min_y: int, max_y: int) -> str:
    width = max_x - min_x + 1
    height = max_y - min_y + 1

    assert (width + 1) % (WIDTH + 1) == 0, 'Uneven amount of letters: width %d' % width
    assert height == HEIGHT, 'Font height %d != 6' % height

    dx = 0
    letters = []
    while dx < width:
        for letter, pattern in LETTERS:
            if dx + WIDTH <= width:  # This letter can fit in the provided width
                if all((pattern[y][x] == '#') == ((min_x + dx + x, min_y + y) in points)
                       for x in range(WIDTH)
                       for y in range(HEIGHT)):
                    letters.append(letter)
                    dx += WIDTH + 1
                    break
        else:
            raise ValueError('No matching text found! Found start = %s at offset dx = %d' % (letters, dx))
    return ''.join(letters)
